package org.schabi.newpipe.player.helper

import android.annotation.SuppressLint
import android.content.Context
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.provider.Settings
import android.view.accessibility.CaptioningManager
import androidx.annotation.IntDef
import androidx.core.content.ContextCompat
import androidx.preference.PreferenceManager
import com.google.android.exoplayer2.PlaybackParameters
import com.google.android.exoplayer2.Player
import com.google.android.exoplayer2.SeekParameters
import com.google.android.exoplayer2.source.ProgressiveMediaSource
import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection
import com.google.android.exoplayer2.trackselection.ExoTrackSelection
import com.google.android.exoplayer2.ui.AspectRatioFrameLayout
import com.google.android.exoplayer2.ui.AspectRatioFrameLayout.ResizeMode
import com.google.android.exoplayer2.ui.CaptionStyleCompat
import com.google.android.exoplayer2.util.MimeTypes
import org.schabi.newpipe.R
import org.schabi.newpipe.extractor.InfoItem
import org.schabi.newpipe.extractor.MediaFormat
import org.schabi.newpipe.extractor.stream.StreamInfo
import org.schabi.newpipe.extractor.stream.StreamInfoItem
import org.schabi.newpipe.extractor.stream.SubtitlesStream
import org.schabi.newpipe.extractor.utils.Utils
import org.schabi.newpipe.player.playqueue.PlayQueue
import org.schabi.newpipe.player.playqueue.PlayQueueItem
import org.schabi.newpipe.player.playqueue.SinglePlayQueue
import org.schabi.newpipe.util.ListHelper
import java.text.DecimalFormat
import java.text.NumberFormat
import java.util.Collections
import java.util.Formatter
import java.util.Locale
import java.util.Objects
import java.util.concurrent.TimeUnit

object PlayerHelper {
    private val STRING_BUILDER: StringBuilder = StringBuilder()
    private val STRING_FORMATTER: Formatter = Formatter(STRING_BUILDER, Locale.getDefault())
    private val SPEED_FORMATTER: NumberFormat = DecimalFormat("0.##x")
    private val PITCH_FORMATTER: NumberFormat = DecimalFormat("##%")

    ////////////////////////////////////////////////////////////////////////////
    // Exposed helpers
    ////////////////////////////////////////////////////////////////////////////
    fun getTimeString(milliSeconds: Int): String {
        val seconds: Int = (milliSeconds % 60000) / 1000
        val minutes: Int = (milliSeconds % 3600000) / 60000
        val hours: Int = (milliSeconds % 86400000) / 3600000
        val days: Int = (milliSeconds % (86400000 * 7)) / 86400000
        STRING_BUILDER.setLength(0)
        return (if (days > 0) STRING_FORMATTER.format("%d:%02d:%02d:%02d", days, hours, minutes, seconds) else if (hours > 0) STRING_FORMATTER.format("%d:%02d:%02d", hours, minutes, seconds) else STRING_FORMATTER.format("%02d:%02d", minutes, seconds)).toString()
    }

    fun formatSpeed(speed: Double): String {
        return SPEED_FORMATTER.format(speed)
    }

    fun formatPitch(pitch: Double): String {
        return PITCH_FORMATTER.format(pitch)
    }

    fun subtitleMimeTypesOf(format: MediaFormat): String {
        when (format) {
            MediaFormat.VTT -> return MimeTypes.TEXT_VTT
            MediaFormat.TTML -> return MimeTypes.APPLICATION_TTML
            else -> throw IllegalArgumentException("Unrecognized mime type: " + format.name)
        }
    }

    fun captionLanguageOf(context: Context,
                          subtitles: SubtitlesStream): String {
        val displayName: String = subtitles.getDisplayLanguageName()
        return displayName + (if (subtitles.isAutoGenerated()) " (" + context.getString(R.string.caption_auto_generated) + ")" else "")
    }

    fun captionLanguageStemOf(language: String): String {
        if (!language.contains("(") || !language.contains(")")) {
            return language
        }
        if (language.startsWith("(")) {
            // language text is right-to-left
            val parts: Array<String> = language.split("\\)".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()
            return parts.get(parts.size - 1).trim({ it <= ' ' })
        }
        return language.split("\\(".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray().get(0).trim({ it <= ' ' })
    }

    fun resizeTypeOf(context: Context,
                     resizeMode: @ResizeMode Int): String {
        when (resizeMode) {
            AspectRatioFrameLayout.RESIZE_MODE_FIT -> return context.getResources().getString(R.string.resize_fit)
            AspectRatioFrameLayout.RESIZE_MODE_FILL -> return context.getResources().getString(R.string.resize_fill)
            AspectRatioFrameLayout.RESIZE_MODE_ZOOM -> return context.getResources().getString(R.string.resize_zoom)
            AspectRatioFrameLayout.RESIZE_MODE_FIXED_HEIGHT, AspectRatioFrameLayout.RESIZE_MODE_FIXED_WIDTH -> throw IllegalArgumentException("Unrecognized resize mode: " + resizeMode)
            else -> throw IllegalArgumentException("Unrecognized resize mode: " + resizeMode)
        }
    }

    /**
     * Given a [StreamInfo] and the existing queue items,
     * provide the [SinglePlayQueue] consisting of the next video for auto queueing.
     *
     *
     * This method detects and prevents cycles by naively checking
     * if a candidate next video's url already exists in the existing items.
     *
     *
     *
     * The first item in [StreamInfo.getRelatedItems] is checked first.
     * If it is non-null and is not part of the existing items, it will be used as the next stream.
     * Otherwise, a random stream with non-repeating url will be selected
     * from the [StreamInfo.getRelatedItems]. Non-stream items are ignored.
     *
     *
     * @param info          currently playing stream
     * @param existingItems existing items in the queue
     * @return [SinglePlayQueue] with the next stream to queue
     */
    fun autoQueueOf(info: StreamInfo,
                    existingItems: List<PlayQueueItem?>): PlayQueue? {
        val urls: MutableSet<String> = HashSet(existingItems.size)
        for (item: PlayQueueItem? in existingItems) {
            urls.add(item.getUrl())
        }
        val relatedItems: List<InfoItem?> = info.getRelatedItems()
        if (Utils.isNullOrEmpty(relatedItems)) {
            return null
        }
        if ((relatedItems.get(0) is StreamInfoItem
                        && !urls.contains(relatedItems.get(0).getUrl()))) {
            return getAutoQueuedSinglePlayQueue(relatedItems.get(0) as StreamInfoItem?)
        }
        val autoQueueItems: MutableList<StreamInfoItem?> = ArrayList()
        for (item: InfoItem? in relatedItems) {
            if (item is StreamInfoItem && !urls.contains(item.getUrl())) {
                autoQueueItems.add(item as StreamInfoItem?)
            }
        }
        Collections.shuffle(autoQueueItems)
        return if (autoQueueItems.isEmpty()) null else getAutoQueuedSinglePlayQueue(autoQueueItems.get(0))
    }

    ////////////////////////////////////////////////////////////////////////////
    // Settings Resolution
    ////////////////////////////////////////////////////////////////////////////
    fun isResumeAfterAudioFocusGain(context: Context): Boolean {
        return getPreferences(context)
                .getBoolean(context.getString(R.string.resume_on_audio_focus_gain_key), false)
    }

    fun getActionForRightGestureSide(context: Context): String? {
        return getPreferences(context)
                .getString(context.getString(R.string.right_gesture_control_key),
                        context.getString(R.string.default_right_gesture_control_value))
    }

    fun getActionForLeftGestureSide(context: Context): String? {
        return getPreferences(context)
                .getString(context.getString(R.string.left_gesture_control_key),
                        context.getString(R.string.default_left_gesture_control_value))
    }

    fun isStartMainPlayerFullscreenEnabled(context: Context): Boolean {
        return getPreferences(context)
                .getBoolean(context.getString(R.string.start_main_player_fullscreen_key), false)
    }

    fun isAutoQueueEnabled(context: Context): Boolean {
        return getPreferences(context)
                .getBoolean(context.getString(R.string.auto_queue_key), false)
    }

    fun isClearingQueueConfirmationRequired(context: Context): Boolean {
        return getPreferences(context)
                .getBoolean(context.getString(R.string.clear_queue_confirmation_key), false)
    }

    @MinimizeMode
    fun getMinimizeOnExitAction(context: Context): Int {
        val action: String? = getPreferences(context)
                .getString(context.getString(R.string.minimize_on_exit_key), "")
        if ((action == context.getString(R.string.minimize_on_exit_popup_key))) {
            return MinimizeMode.MINIMIZE_ON_EXIT_MODE_POPUP
        } else if ((action == context.getString(R.string.minimize_on_exit_none_key))) {
            return MinimizeMode.MINIMIZE_ON_EXIT_MODE_NONE
        } else {
            return MinimizeMode.MINIMIZE_ON_EXIT_MODE_BACKGROUND // default
        }
    }

    @AutoplayType
    fun getAutoplayType(context: Context): Int {
        val type: String? = getPreferences(context).getString(
                context.getString(R.string.autoplay_key), "")
        if ((type == context.getString(R.string.autoplay_always_key))) {
            return AutoplayType.AUTOPLAY_TYPE_ALWAYS
        } else if ((type == context.getString(R.string.autoplay_never_key))) {
            return AutoplayType.AUTOPLAY_TYPE_NEVER
        } else {
            return AutoplayType.AUTOPLAY_TYPE_WIFI // default
        }
    }

    fun isAutoplayAllowedByUser(context: Context): Boolean {
        when (getAutoplayType(context)) {
            AutoplayType.AUTOPLAY_TYPE_NEVER -> return false
            AutoplayType.AUTOPLAY_TYPE_WIFI -> return !ListHelper.isMeteredNetwork(context)
            AutoplayType.AUTOPLAY_TYPE_ALWAYS -> return true
            else -> return true
        }
    }

    fun getSeekParameters(context: Context): SeekParameters {
        return if (isUsingInexactSeek(context)) SeekParameters.CLOSEST_SYNC else SeekParameters.EXACT
    }

    val preferredCacheSize: Long
        get() {
            return 64 * 1024 * 1024L
        }
    val preferredFileSize: Long
        get() {
            return 2 * 1024 * 1024L // ExoPlayer CacheDataSink.MIN_RECOMMENDED_FRAGMENT_SIZE
        }
    val qualitySelector: ExoTrackSelection.Factory
        get() {
            return AdaptiveTrackSelection.Factory(
                    1000,
                    AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
                    AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
                    AdaptiveTrackSelection.DEFAULT_BANDWIDTH_FRACTION)
        }
    val isUsingDSP: Boolean
        get() {
            return true
        }

    fun getCaptionStyle(context: Context): CaptionStyleCompat {
        val captioningManager: CaptioningManager? = ContextCompat.getSystemService(context,
                CaptioningManager::class.java)
        if (captioningManager == null || !captioningManager.isEnabled()) {
            return CaptionStyleCompat.DEFAULT
        }
        return CaptionStyleCompat.createFromCaptionStyle(captioningManager.getUserStyle())
    }

    /**
     * Get scaling for captions based on system font scaling.
     *
     * Options:
     *
     *  * Very small: 0.25f
     *  * Small: 0.5f
     *  * Normal: 1.0f
     *  * Large: 1.5f
     *  * Very large: 2.0f
     *
     *
     * @param context Android app context
     * @return caption scaling
     */
    fun getCaptionScale(context: Context): Float {
        val captioningManager: CaptioningManager? = ContextCompat.getSystemService(context,
                CaptioningManager::class.java)
        if (captioningManager == null || !captioningManager.isEnabled()) {
            return 1.0f
        }
        return captioningManager.getFontScale()
    }

    /**
     * @param context the Android context
     * @return the screen brightness to use. A value less than 0 (the default) means to use the
     * preferred screen brightness
     */
    fun getScreenBrightness(context: Context): Float {
        val sp: SharedPreferences = getPreferences(context)
        val timestamp: Long = sp.getLong(context.getString(R.string.screen_brightness_timestamp_key), 0)
        // Hypothesis: 4h covers a viewing block, e.g. evening.
        // External lightning conditions will change in the next
        // viewing block so we fall back to the default brightness
        if ((System.currentTimeMillis() - timestamp) > TimeUnit.HOURS.toMillis(4)) {
            return (-1).toFloat()
        } else {
            return sp.getFloat(context.getString(R.string.screen_brightness_key), -1f)
        }
    }

    fun setScreenBrightness(context: Context,
                            screenBrightness: Float) {
        getPreferences(context).edit()
                .putFloat(context.getString(R.string.screen_brightness_key), screenBrightness)
                .putLong(context.getString(R.string.screen_brightness_timestamp_key),
                        System.currentTimeMillis())
                .apply()
    }

    fun globalScreenOrientationLocked(context: Context?): Boolean {
        // 1: Screen orientation changes using accelerometer
        // 0: Screen orientation is locked
        // if the accelerometer sensor is missing completely, assume locked orientation
        return (Settings.System.getInt(
                context!!.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0) == 0
                || !context.getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_SENSOR_ACCELEROMETER))
    }

    fun getProgressiveLoadIntervalBytes(context: Context): Int {
        val preferredIntervalBytes: String? = getPreferences(context).getString(
                context.getString(R.string.progressive_load_interval_key),
                context.getString(R.string.progressive_load_interval_default_value))
        if ((context.getString(R.string.progressive_load_interval_exoplayer_default_value)
                        == preferredIntervalBytes)) {
            return ProgressiveMediaSource.DEFAULT_LOADING_CHECK_INTERVAL_BYTES
        }
        // Keeping the same KiB unit used by ProgressiveMediaSource
        return preferredIntervalBytes!!.toInt() * 1024
    }

    ////////////////////////////////////////////////////////////////////////////
    // Private helpers
    ////////////////////////////////////////////////////////////////////////////
    private fun getPreferences(context: Context): SharedPreferences {
        return PreferenceManager.getDefaultSharedPreferences(context)
    }

    private fun isUsingInexactSeek(context: Context): Boolean {
        return getPreferences(context)
                .getBoolean(context.getString(R.string.use_inexact_seek_key), false)
    }

    private fun getAutoQueuedSinglePlayQueue(
            streamInfoItem: StreamInfoItem?): SinglePlayQueue {
        val singlePlayQueue: SinglePlayQueue = SinglePlayQueue((streamInfoItem)!!)
        Objects.requireNonNull(singlePlayQueue.getItem()).setAutoQueued(true)
        return singlePlayQueue
    }

    ////////////////////////////////////////////////////////////////////////////
    // Utils used by player
    ////////////////////////////////////////////////////////////////////////////
    fun nextRepeatMode(repeatMode: @Player.RepeatMode Int): @Player.RepeatMode Int {
        when (repeatMode) {
            Player.REPEAT_MODE_OFF -> return Player.REPEAT_MODE_ONE
            Player.REPEAT_MODE_ONE -> return Player.REPEAT_MODE_ALL
            Player.REPEAT_MODE_ALL -> return Player.REPEAT_MODE_OFF
            else -> return Player.REPEAT_MODE_OFF
        }
    }

    fun retrieveResizeModeFromPrefs(player: org.schabi.newpipe.player.Player): @ResizeMode Int {
        return player.getPrefs().getInt(player.getContext().getString(R.string.last_resize_mode),
                AspectRatioFrameLayout.RESIZE_MODE_FIT)
    }

    @SuppressLint("SwitchIntDef") // only fit, fill and zoom are supported by NewPipe
    fun nextResizeModeAndSaveToPrefs(player: org.schabi.newpipe.player.Player,
                                     resizeMode: @ResizeMode Int): @ResizeMode Int {
        val newResizeMode: Int
        when (resizeMode) {
            AspectRatioFrameLayout.RESIZE_MODE_FIT -> newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL
            AspectRatioFrameLayout.RESIZE_MODE_FILL -> newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM
            AspectRatioFrameLayout.RESIZE_MODE_ZOOM -> newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT
            else -> newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT
        }

        // save the new resize mode so it can be restored in a future session
        player.getPrefs().edit().putInt(
                player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply()
        return newResizeMode
    }

    fun retrievePlaybackParametersFromPrefs(player: org.schabi.newpipe.player.Player): PlaybackParameters {
        val speed: Float = player.getPrefs().getFloat(player.getContext().getString(
                R.string.playback_speed_key), player.getPlaybackSpeed())
        val pitch: Float = player.getPrefs().getFloat(player.getContext().getString(
                R.string.playback_pitch_key), player.getPlaybackPitch())
        return PlaybackParameters(speed, pitch)
    }

    fun savePlaybackParametersToPrefs(player: org.schabi.newpipe.player.Player,
                                      speed: Float,
                                      pitch: Float,
                                      skipSilence: Boolean) {
        player.getPrefs().edit()
                .putFloat(player.getContext().getString(R.string.playback_speed_key), speed)
                .putFloat(player.getContext().getString(R.string.playback_pitch_key), pitch)
                .putBoolean(player.getContext().getString(R.string.playback_skip_silence_key),
                        skipSilence)
                .apply()
    }

    fun getMinimumVideoHeight(width: Float): Float {
        return width / (16.0f / 9.0f) // Respect the 16:9 ratio that most videos have
    }

    fun retrieveSeekDurationFromPreferences(player: org.schabi.newpipe.player.Player): Int {
        return Objects.requireNonNull(player.getPrefs().getString(
                player.getContext().getString(R.string.seek_duration_key),
                player.getContext().getString(R.string.seek_duration_default_value))).toInt()
    }

    @Retention(AnnotationRetention.SOURCE)
    @IntDef([AutoplayType.AUTOPLAY_TYPE_ALWAYS, AutoplayType.AUTOPLAY_TYPE_WIFI, AutoplayType.AUTOPLAY_TYPE_NEVER])
    annotation class AutoplayType() {
        companion object {
            val AUTOPLAY_TYPE_ALWAYS: Int = 0
            val AUTOPLAY_TYPE_WIFI: Int = 1
            val AUTOPLAY_TYPE_NEVER: Int = 2
        }
    }

    @Retention(AnnotationRetention.SOURCE)
    @IntDef([MinimizeMode.MINIMIZE_ON_EXIT_MODE_NONE, MinimizeMode.MINIMIZE_ON_EXIT_MODE_BACKGROUND, MinimizeMode.MINIMIZE_ON_EXIT_MODE_POPUP])
    annotation class MinimizeMode() {
        companion object {
            val MINIMIZE_ON_EXIT_MODE_NONE: Int = 0
            val MINIMIZE_ON_EXIT_MODE_BACKGROUND: Int = 1
            val MINIMIZE_ON_EXIT_MODE_POPUP: Int = 2
        }
    }
}
